#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_NUMBERS 8
#define MAX_BRACE_BUFFER 65536
#define MAX_PAREN_NUMBERS 128

typedef enum {
  SKODE_START,
  SKODE_COMMAND,
  SKODE_NUMBER,
  SKODE_COMMENT,
  SKODE_BRACE_CONTENT,
  SKODE_PAREN_NUMBERS
} skode_state_t;

typedef struct {
  char cmd[3];       // Command (e.g., "f", "/f", "+", "~")
  float numbers[MAX_NUMBERS];
  int num_count;
  
  // Brace content buffer
  //char brace_buf[MAX_BRACE_BUFFER];
  char *brace_buf;
  int brace_max;
  int brace_len;
  int brace_complete;
  
  // Paren numbers
  //float paren_numbers[MAX_PAREN_NUMBERS];
  float *paren_numbers;
  int paren_count;
  int paren_max;
  int paren_complete;
} skode_command_t;

typedef struct {
  skode_state_t state;
  char cmd_buf[3];
  int cmd_len;
  char num_buf[32];
  int num_len;
  skode_command_t current;
} skode_t;

void skode_init(skode_t *p) {
  p->state = SKODE_START;
  p->cmd_len = 0;
  p->num_len = 0;
  p->current.cmd[0] = '\0';
  p->current.num_count = 0;
  p->current.brace_len = 0;
  p->current.brace_max = MAX_BRACE_BUFFER;
  p->current.brace_buf = malloc(MAX_BRACE_BUFFER);
  p->current.brace_complete = 0;
  p->current.paren_count = 0;
  p->current.paren_max = MAX_PAREN_NUMBERS;
  p->current.paren_numbers = malloc(MAX_PAREN_NUMBERS);
  p->current.paren_complete = 0;
}

void skode_free(skode_t *p) {
  if (p->current.brace_buf) free(p->current.brace_buf);
  p->current.brace_buf = NULL;
  if (p->current.paren_numbers) free(p->current.paren_numbers);
  p->current.paren_numbers = NULL;
}

static void emit_command(skode_command_t *cmd) {
  if (cmd->cmd[0] == '\0' && cmd->brace_len == 0 && cmd->paren_count == 0) return;
  
  if (cmd->cmd[0] != '\0') {
    printf("cmd %s", cmd->cmd);
    if (cmd->num_count > 0) {
      printf(" [");
      for (int i = 0; i < cmd->num_count; i++) {
        printf("%g", cmd->numbers[i]);
        if (i < cmd->num_count - 1) printf(" ");
      }
      printf("]");
    }
    printf("\n");
  }
  
  if (cmd->brace_len > 0 && cmd->brace_complete) {
    printf("str {%.*s}\n", cmd->brace_len, cmd->brace_buf);
  }
  
  if (cmd->paren_count > 0 && cmd->paren_complete) {
    printf("data (");
    for (int i = 0; i < cmd->paren_count; i++) {
      printf("%g", cmd->paren_numbers[i]);
      if (i < cmd->paren_count - 1) printf(" ");
    }
    printf(")\n");
  }
}

static void finish_number(skode_t *p) {
  if (p->num_len > 0) {
    p->num_buf[p->num_len] = '\0';
    if (p->current.num_count < MAX_NUMBERS) {
      p->current.numbers[p->current.num_count++] = atof(p->num_buf);
    }
    p->num_len = 0;
  }
}

static void finish_paren_number(skode_t *p) {
  if (p->num_len > 0) {
    p->num_buf[p->num_len] = '\0';
    if (p->current.paren_count < p->current.paren_max) {
      p->current.paren_numbers[p->current.paren_count++] = atof(p->num_buf);
    }
    p->num_len = 0;
  }
}

void skode_finish(skode_t *p, int debug) {
  finish_number(p);
  if (debug) emit_command(&p->current);
  /*
    things using this should check the same things emit_command use:
      cmd->current->cmd
      cmd->current->num_count
      cmd->current->brace_len and brace_complete
      cmd->current->paren_count and paren_complete
    so maybe the interface could be simpler/cleaner?
  */
  p->current.cmd[0] = '\0';
  p->current.num_count = 0;
  p->current.brace_len = 0;
  p->current.brace_complete = 0;
  p->current.paren_count = 0;
  p->current.paren_complete = 0;
  p->state = SKODE_START;
}

static int is_command_char(char c) {
  return isalpha(c) || c == '/' || c == ':' || c == '+' || c == '~';
}

static int is_number_char(char c) {
  return isdigit(c) || c == '.' || c == '-' || c == 'e' || c == 'E';
}

void skode_chunk(skode_t *p, const char *chunk, int len, int debug) {
  for (int i = 0; i < len; i++) {
    char c = chunk[i];
    
    switch (p->state) {
      case SKODE_START:
        if (c == '#') {
          skode_finish(p, debug);
          p->state = SKODE_COMMENT;
        } else if (c == ';') {
          skode_finish(p, debug);
        } else if (c == '\n') {
          // Newline only finishes command if we have numbers
          if (p->current.num_count > 0 || p->num_len > 0) {
            skode_finish(p, debug);
          }
        } else if (c == '{') {
          skode_finish(p, debug);
          p->current.brace_len = 0;
          p->current.brace_complete = 0;
          p->state = SKODE_BRACE_CONTENT;
        } else if (c == '(') {
          skode_finish(p, debug);
          p->current.paren_count = 0;
          p->current.paren_complete = 0;
          p->num_len = 0;
          p->state = SKODE_PAREN_NUMBERS;
        } else if (c == '/' || c == ':') {
          skode_finish(p, debug);
          p->cmd_buf[0] = '/';
          p->cmd_len = 1;
          p->state = SKODE_COMMAND;
        } else if (c == '+' || c == '~') {
          // Timing command
          skode_finish(p, debug);
          p->cmd_buf[0] = c;
          p->cmd_len = 1;
          p->cmd_buf[1] = '\0';
          strcpy(p->current.cmd, p->cmd_buf);
          p->state = SKODE_NUMBER;
        } else if (isalpha(c)) {
          skode_finish(p, debug);
          p->cmd_buf[0] = c;
          p->cmd_len = 1;
          p->cmd_buf[1] = '\0';
          strcpy(p->current.cmd, p->cmd_buf);
          p->state = SKODE_NUMBER;
        } else if (!isspace(c) && c != ',') {
          // Invalid character at start
        }
        break;
        
      case SKODE_COMMAND:
        if (isalpha(c)) {
          p->cmd_buf[p->cmd_len++] = c;
          p->cmd_buf[p->cmd_len] = '\0';
          strcpy(p->current.cmd, p->cmd_buf);
          p->state = SKODE_NUMBER;
        } else if (c == '\n' || c == ';') {
          skode_finish(p, debug);
        } else if (!isspace(c) && c != ',') {
          // Invalid after slash
          p->state = SKODE_START;
        }
        break;
        
      case SKODE_NUMBER:
        if (is_number_char(c)) {
          if (p->num_len == 0 || p->num_len < 31) {
            p->num_buf[p->num_len++] = c;
          }
        } else if (c == ' ' || c == '\t' || c == ',') {
          finish_number(p);
        } else if (c == ';') {
          skode_finish(p, debug);
        } else if (c == '\n') {
          // Newline only finishes command if we have numbers
          if (p->current.num_count > 0 || p->num_len > 0) {
            skode_finish(p, debug);
          }
        } else if (c == '#') {
          skode_finish(p, debug);
          p->state = SKODE_COMMENT;
        } else if (is_command_char(c)) {
          // Any command character starts a new command
          skode_finish(p, debug);
          i--; // Reprocess this character
        } else if (c == '{') {
          skode_finish(p, debug);
          p->current.brace_len = 0;
          p->current.brace_complete = 0;
          p->state = SKODE_BRACE_CONTENT;
        } else if (c == '(') {
          skode_finish(p, debug);
          p->current.paren_count = 0;
          p->current.paren_complete = 0;
          p->num_len = 0;
          p->state = SKODE_PAREN_NUMBERS;
        }
        break;
        
      case SKODE_BRACE_CONTENT:
        if (c == '}') {
          p->current.brace_complete = 1;
          skode_finish(p, debug);
        } else {
          // Collect character if buffer not full
          if (p->current.brace_len < p->current.brace_max - 1) {
            p->current.brace_buf[p->current.brace_len++] = c;
          }
          // Continue reading until '}' even if buffer is full
        }
        break;
        
      case SKODE_PAREN_NUMBERS:
        if (is_number_char(c)) {
          if (p->num_len < 31) {
            p->num_buf[p->num_len++] = c;
          }
        } else if (c == ' ' || c == '\t' || c == '\n' || c == ',') {
          finish_paren_number(p);
        } else if (c == ')') {
          finish_paren_number(p);
          p->current.paren_complete = 1;
          skode_finish(p, debug);
        }
        break;
        
      case SKODE_COMMENT:
        if (c == '\n') {
          p->state = SKODE_START;
        }
        break;
    }
  }
}

void test(skode_t *parser) {
  // Test cases
  const char *tests[] = {
    "f100 ",
    "f 100\n",
    "f 100.1 -5.1\n",
    "/f 10 10\n",
    "a 100 ; b ",
    "; c 100 100.\n",
    "# comment line\n",
    "g 1 2 3\n",
    "x 1.5e3 2.1e-2 3E+4\n",
    "v0Tv1T+.5~.5\n",
    "/s/s/s\n",
    "+ .5\n",
    "~ .5\n",
    "m\n",
    "200 150\n",
    "{hello world}\n",
    "(1.5 2.3 -4.5)\n",
    "g1 {some text} (10 20 30)\n",
    "(1 2 3 4 5\n",
    "-1.5 1e-5\n",
    "1 2 3\n",
    "100\n",
    ")\n"
  };
  
  printf("Parsing test chunks:\n");
  printf("====================\n\n");
  
  for (int i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {
    printf("Chunk %d: \"%s\"\n", i+1, tests[i]);
    skode_chunk(parser, tests[i], strlen(tests[i]), 1);
  }
  
  // Finish any remaining command
  if (parser->current.cmd[0] != '\0' || parser->num_len > 0) {
    skode_finish(parser, 1);
  }
}

int main(int argc, char *argv[]) {
  skode_t parser;
  skode_init(&parser);
  
  if (argc > 1) {
    char *name = argv[1];
    FILE *in = stdin;
    if (strcmp(name, "-") != 0) in = fopen(name, "r");
    if (in) {
      char line[1024];
      while (fgets(line, sizeof(line), in) != NULL) {
        size_t len = strlen(line);
        if (len == 0) continue;
        printf("<%s>\n", line);
        skode_chunk(&parser, line, len, 1);
      }
      fclose(in);
    }
  } else {
    test(&parser);
  }
  skode_free(&parser);
  
  return 0;
}