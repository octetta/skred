#!/usr/bin/env tclsh

proc daemonize {} {
  global argv argv0
  set cmd [list exec tclsh $argv0]
  lappend cmd -daemon
  lappend cmd {*}$argv
  lappend cmd &
  if {[catch $cmd result]} {
    puts stderr "did not fork -> $result"
    exit 1
  }
  exit 0
}

package require udp

set addr 127.0.0.1
set port 60440

set sock [udp_open]
fconfigure $sock -buffering none -translation binary

proc dest {addr port} {
  fconfigure $::sock -remote [list $addr $port]
}

dest $addr $port

proc wire {msg} {
  puts -nonewline $::sock $msg
  # puts $msg
}

# Check if already running as daemon
if {[lsearch $argv "-daemon"] != -1} {
  close stdin
  close stdout
  close stderr
    
  # Change working directory to /tmp (safe?)
  cd /tmp
    
  set min_val 0
  set max_val 880
  set step_val 0.0001
  set current_val 440
  set wire_string "f%s"
  set window_title "fire"

  set wire_check 1

  if {$argc > 1} {set min_val [lindex $argv 1]}
  if {$argc > 2} {set max_val [lindex $argv 2]}
  if {$argc > 3} {set step_val [lindex $argv 3]}
  if {$argc > 4} {set wire_string [lindex $argv 4]}
  if {$argc > 5} {set current_val [lindex $argv 5]}
  if {$argc > 6} {set window_title [lindex $argv 6]}
  
  package require Tk
  wm title . $window_title
  wm geometry . ;# 400x350

  # Create frame for input fields
  frame .inputs ;# -relief raised -bd 1
  pack .inputs -side top -fill x -padx 4 -pady 4

  # Create labels and entry fields for A, B, C, and Format
  label .inputs.labelA -text "min"
  entry .inputs.entryA -textvariable min_val -width 10
  grid .inputs.labelA .inputs.entryA -sticky w -padx 5 -pady 2

  label .inputs.labelB -text "max"
  entry .inputs.entryB -textvariable max_val -width 10
  grid .inputs.labelB .inputs.entryB -sticky w -padx 5 -pady 2

  label .inputs.labelC -text "step"
  entry .inputs.entryC -textvariable step_val -width 10
  grid .inputs.labelC .inputs.entryC -sticky w -padx 5 -pady 2

  label .inputs.labelFormat -text "wire"
  entry .inputs.entryFormat -textvariable wire_string -width 20
  checkbutton .inputs.entryCheck -variable wire_check -text {}
  # grid .inputs.labelFormat .inputs.entryFormat -sticky w -padx 5 -pady 2
  grid .inputs.labelFormat .inputs.entryFormat .inputs.entryCheck -sticky w -padx 5 -pady 2

  # Update button
  button .inputs.update -text "update" -command updateSlider
  grid .inputs.update -columnspan 2 -pady 2

  # Bind Enter key to update slider for each entry field
  bind .inputs.entryA <Return> updateSlider
  bind .inputs.entryB <Return> updateSlider
  bind .inputs.entryC <Return> updateSlider
  bind .inputs.entryFormat <Return> updateSlider

  frame .buttonGrid
  set voice -1

proc toggleButton {num} {
  global voice
    
  if {$voice == $num} {
    .buttonGrid.b$num configure -relief raised
    set voice -1
    return
  }

  # Deselect previous button
  if {$voice >= 0} {
    .buttonGrid.b$voice configure -relief raised
  }
    
  # Select new button
  set voice $num
  .buttonGrid.b$num configure -relief sunken
}

  for {set i 0} {$i < 32} {incr i} {
    button .buttonGrid.b$i -text $i -padx 0 -pady 0 -font {Arial 7} -bd 1 \
      -command "toggleButton $i"
    grid .buttonGrid.b$i -row [expr {$i / 16}] -column [expr {$i % 16}] \
      -sticky nsew
  }

  pack .buttonGrid

  # Create frame for slider
  frame .sliderFrame ;# -relief raised -bd 1
  pack .sliderFrame -side top -fill both -expand true -padx 4 -pady 4

  # Create the slider
  scale .slider -from $min_val -to $max_val -resolution $step_val \
    -orient horizontal -variable current_val -command {fire}
  pack .slider -in .sliderFrame -side top -fill x -pady 10
} else {
  daemonize
}

proc fire {value} {
    global current_val wire_string
    set tmp $wire_string
    if {$::voice >= 0} {
      set tmp "v$::voice $wire_string"
    } {
      set tmp $wire_string
    }
    global wire_check
    if {$wire_check == 0} {
      set fmt $tmp
    } {
      set fmt "\[$tmp\]"
    }
    set current_val $value
    set formattedOutput [format $fmt $value]
    wire $formattedOutput
}

# Procedure to update slider configuration
proc updateSlider {} {
    global min_val max_val step_val current_val
    
    # Validate inputs
    if {![string is double $min_val] || ![string is double $max_val] || ![string is double $step_val]} {
        tk_messageBox -type ok -icon error -title "Error" -message "Please enter valid numeric values"
        return
    }
    
    if {$step_val <= 0} {
        tk_messageBox -type ok -icon error -title "Error" -message "Step value must be greater than 0"
        return
    }
    
    if {$min_val >= $max_val} {
        tk_messageBox -type ok -icon error -title "Error" -message "Minimum value must be less than maximum value"
        return
    }
    
    # Temporarily remove the command to prevent fire from being called
    .slider configure -command {}
    
    # Update slider configuration
    .slider configure -from $min_val -to $max_val -resolution $step_val
    
    # Only adjust current value if it's outside the new range
    if {$current_val < $min_val || $current_val > $max_val} {
        set current_val $min_val
    }
    
    # Restore the command after updating
    .slider configure -command {fire}
    
    # puts "Slider updated: Min=$min_val, Max=$max_val, Step=$step_val"
}

proc main {min_val max_val step_val current_val wire_string wire_check window_title} {
# Create main window
}
