#!/usr/bin/env tclsh8.6

set TCL tclsh8.6

proc daemonize {} {
  global argv argv0
  set cmd [list exec $::TCL $argv0]
  lappend cmd -daemon
  lappend cmd {*}$argv
  lappend cmd &
  if {[catch $cmd result]} {
    puts stderr "did not fork -> $result"
    exit 1
  }
  exit 0
}

package require udp

set addr 127.0.0.1
set port 60440

set sock [udp_open 0]
fconfigure $sock -buffering none -translation binary
fconfigure $sock -remote [list $addr $port]

proc dest {} {
  global addr port sock
}

proc change_addr_port {} {
  global addr port sock wire_addr wire_port
  
  if {($addr != $wire_addr) || ($port != $wire_port)} {
    # puts "change from ($addr $port) -> ($wire_addr $wire_port)"
    
    # Try multiple times with delays
    set attempts 0
    set new_sock ""
    
    while {$attempts < 5} {
      incr attempts
      # puts "Attempt $attempts..."
      
      set new_sock [udp_open]
      
      if {$new_sock in [file channels]} {
        # puts "  SUCCESS on attempt $attempts"
        # puts "  udp_open returned: $new_sock"
        # puts "  file channels: [file channels]"
        break
      }
      
      after 50  ;# Wait 50ms
      update
    }
    
    if {$new_sock ni [file channels]} {
      puts "FAILED after $attempts attempts"
      tk_messageBox -message "Cannot create UDP socket. Check if tcpudp extension is working." -type ok
      return
    }
    
    # Close old socket
    if {[info exists sock]} {
      catch {close $sock}
    }
    
    set ::addr $wire_addr
    set ::port $wire_port
    fconfigure $new_sock -buffering none -translation binary
    fconfigure $new_sock -remote [list $::addr $::port]
    set ::sock $new_sock
  }
}

proc wire {msg} {
  global sock
  puts -nonewline $sock $msg
  # puts $msg
}

# Check if already running as daemon
if {[lsearch $argv "-daemon"] != -1} {
  close stdin
  # close stdout
  close stderr
    
  # Change working directory to /tmp (safe?)
  cd /tmp
    
  set min_val 0
  set max_val 880
  set step_val 0.0001
  set current_val 440
  set wire_string "f%s"
  set window_title "fire"
  set wire_addr 127.0.0.1
  set wire_port 60440

  set wire_check 1

  if {$argc > 1} {set min_val [lindex $argv 1]}
  if {$argc > 2} {set max_val [lindex $argv 2]}
  if {$argc > 3} {set step_val [lindex $argv 3]}
  if {$argc > 4} {set wire_string [lindex $argv 4]}
  if {$argc > 5} {set current_val [lindex $argv 5]}
  if {$argc > 6} {set window_title [lindex $argv 6]}
  
  package require Tk
  wm title . $window_title
  wm geometry .

proc resize_window {} {
    update idletasks
    set reqWidth [winfo reqwidth .]
    set reqHeight [winfo reqheight .]
    wm geometry . "${reqWidth}x${reqHeight}"
}

set configVisible 1
proc toggleConfig {} {
    global configVisible
    if {$configVisible} {
        # Hide the frame
        set ::configVisible 0
        pack forget .config
    } else {
        # Show the frame
        set ::configVisible 1
        pack .config -fill both -expand 1 -padx 10 -pady 5 -before .content
    }
    resize_window
}

proc toggle_button {num} {
  global voice
  if {$voice == $num} {
    # .content.buttonGrid.b$num configure -relief raised
    .content.buttonGrid.b$num configure -bg lightblue -relief raised

    set ::voice -1
    return
  }
  # Deselect previous button
  if {$voice >= 0} {
    .content.buttonGrid.b$voice configure -bg lightblue -relief raised
  }
  # Select new button
  set ::voice $num
  .content.buttonGrid.b$num configure -bg orange -relief sunken
}

  font create postitFont -family TkDefaultFont -slant italic

  # Create frame for post-it note and config button
  # #FFFF99 post-it yellow
  # #37BC7D greenish
  # #F54927 redish

  # Create toggle button
  frame .info -bg #FFFF99
  pack .info -side left -side top -fill x -pady 0
  entry .info.note -width 64 -font postitFont -background #FFFF99 -borderwidth 0 -highlightthickness 0
  button .info.toggle -text " config " -command toggleConfig -padx 1 -pady 1 -relief flat -bd 0 -bg #37BC7D -activebackground #F54927
  pack .info.toggle -side left
  pack .info.note -side left -fill x;# -padx 5
  pack .info
  bind .info.note <Return> {wm title . [.info.note get]}

  # Create frame for input fields
  frame .config
  pack .config -side top -fill x -padx 4 -pady 4

  # Create labels and entry fields for A, B, C, and Format
  label .config.labelA -text "min"
  entry .config.entryA -textvariable min_val -width 10
  grid .config.labelA .config.entryA -sticky w -padx 5 -pady 2

  label .config.labelB -text "max"
  entry .config.entryB -textvariable max_val -width 10
  grid .config.labelB .config.entryB -sticky w -padx 5 -pady 2

  label .config.labelC -text "step"
  entry .config.entryC -textvariable step_val -width 10
  grid .config.labelC .config.entryC -sticky w -padx 5 -pady 2

  label .config.labelFormat -text "wire"
  entry .config.entryFormat -textvariable wire_string -width 20
  checkbutton .config.entryCheck -variable wire_check -text {}
  grid .config.labelFormat .config.entryFormat .config.entryCheck -sticky w -padx 5 -pady 2

  label .config.labelComm -text "comm"
  entry .config.entryAddr -textvariable wire_addr -width 20
  entry .config.entryPort -textvariable wire_port -width 20
  grid .config.labelComm .config.entryAddr .config.entryPort -sticky w -padx 5 -pady 2

  # Update button
  button .config.update -text " update " -command update_settings -padx 1 -pady 1 -relief flat -bd 0 -bg orange -activebackground red
  grid .config.update -columnspan 3 -pady 2 -sticky w

  # Bind Enter key to update slider for each entry field
  bind .config.entryA <Return> update_settings
  bind .config.entryB <Return> update_settings
  bind .config.entryC <Return> update_settings
  bind .config.entryFormat <Return> update_settings
  bind .config.entryAddr <Return> update_settings
  bind .config.entryPort <Return> update_settings

  frame .content
  frame .content.buttonGrid
  set ::voice -1

  for {set i 0} {$i < 32} {incr i} {
    button .content.buttonGrid.b$i -text " v$i " -padx 1 -pady 1 -font {Arial 10} -bd 0 \
      -command "toggle_button $i" -bg lightblue
    grid .content.buttonGrid.b$i -row [expr {$i / 16}] -column [expr {$i % 16}] \
      -sticky nsew
  }

  pack .content.buttonGrid -side left -side top -fill x -pady 1
  pack .content -padx 4 -pady 4

  # Create frame for slider
  frame .sliderFrame -bd 0 ;# -relief raised -bd 1
  pack .sliderFrame -side top -fill both -expand true -padx 4 -pady 1

  # Create the slider
  scale .slider -from $min_val -to $max_val -resolution $step_val \
    -orient horizontal -variable current_val -command {fire}
  pack .slider -in .sliderFrame -side top -fill x -pady 10
} else {
  daemonize
}

proc fire {value} {
    global current_val
    global wire_string
    global voice
    set tmp $wire_string
    if {$voice >= 0} {
      set tmp "v$voice $wire_string"
    } {
      set tmp $wire_string
    }
    global wire_check
    if {$wire_check == 0} {
      set fmt $tmp
    } {
      set fmt "\[$tmp\]"
    }
    set current_val $value
    set formattedOutput [format $fmt $value]
    wire $formattedOutput
}

# Procedure to update slider configuration
proc update_settings {} {
    global min_val
    global max_val
    global step_val
    global current_val
    
    # Validate inputs
    if {![string is double $min_val] || ![string is double $max_val] || ![string is double $step_val]} {
        tk_messageBox -type ok -icon error -title "Error" -message "Please enter valid numeric values"
        return
    }
    
    if {$step_val <= 0} {
        tk_messageBox -type ok -icon error -title "Error" -message "Step value must be greater than 0"
        return
    }
    
    if {$min_val >= $max_val} {
        tk_messageBox -type ok -icon error -title "Error" -message "Minimum value must be less than maximum value"
        return
    }
    
    # Temporarily remove the command to prevent fire from being called
    .slider configure -command {}
    
    # Update slider configuration
    .slider configure -from $min_val -to $max_val -resolution $step_val
    
    # Only adjust current value if it's outside the new range
    if {$current_val < $min_val || $current_val > $max_val} {
        set current_val $min_val
    }
    
    # Restore the command after updating
    .slider configure -command {fire}

    change_addr_port
}

proc main {min_val max_val step_val current_val wire_string wire_check window_title} {
# Create main window
}
