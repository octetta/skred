#!/usr/bin/env tclsh

proc daemonize {} {
  global argv argv0
  set cmd [list exec tclsh $argv0]
  lappend cmd -daemon
  lappend cmd {*}$argv
  lappend cmd &
  if {[catch $cmd result]} {
    puts stderr "did not fork -> $result"
    exit 1
  }
  exit 0
}

package require udp

set addr 127.0.0.1
set port 60440

set sock [udp_open]
fconfigure $sock -buffering none -translation binary

proc dest {addr port} {
  fconfigure $::sock -remote [list $addr $port]
}

dest $addr $port

proc wire {msg} {
  puts -nonewline $::sock $msg
  # puts $msg
}

# Check if already running as daemon
if {[lsearch $argv "-daemon"] != -1} {
  close stdin
  close stdout
  close stderr
    
  # Change working directory to /tmp (safe?)
  cd /tmp
    
  set min_val 0
  set max_val 880
  set step_val 0.0001
  set current_val 440
  set wire_string "f%s"
  set window_title "fire"

  set wire_check 1

  if {$argc > 1} {set min_val [lindex $argv 1]}
  if {$argc > 2} {set max_val [lindex $argv 2]}
  if {$argc > 3} {set step_val [lindex $argv 3]}
  if {$argc > 4} {set wire_string [lindex $argv 4]}
  if {$argc > 5} {set current_val [lindex $argv 5]}
  if {$argc > 6} {set window_title [lindex $argv 6]}
  
  package require Tk
  wm title . $window_title
  wm geometry .

proc resizeWindow {} {
    update idletasks
    set reqWidth [winfo reqwidth .]
    set reqHeight [winfo reqheight .]
    wm geometry . "${reqWidth}x${reqHeight}"
}

set ::configVisible 1
proc toggleConfig {} {
    global configVisible
    if {$configVisible} {
        # Hide the frame
        set ::configVisible 0
        pack forget .config
    } else {
        # Show the frame
        set ::configVisible 1
        pack .config -fill both -expand 1 -padx 10 -pady 5 -before .content
    }
    resizeWindow
}

proc toggleButton {num} {
  global voice
  if {$voice == $num} {
    # .content.buttonGrid.b$num configure -relief raised
    .content.buttonGrid.b$num configure -bg lightblue -relief raised

    set voice -1
    return
  }
  # Deselect previous button
  if {$voice >= 0} {
    # .content.buttonGrid.b$voice configure -relief raised
    .content.buttonGrid.b$voice configure -bg lightblue -relief raised
  }
  # Select new button
  set voice $num
  # .content.buttonGrid.b$num configure -relief sunken
  .content.buttonGrid.b$num configure -bg orange -relief sunken
}

  font create postitFont -family TkDefaultFont -slant italic

  # Create frame for post-it note and config button
  # #FFFF99 post-it yellow
  # #37BC7D greenish
  # #F54927 redish

  # Create toggle button
  frame .info -bg #FFFF99
  pack .info -side left -side top -fill x -pady 0
  entry .info.note -width 64 -font postitFont -background #FFFF99 -borderwidth 0 -highlightthickness 0
  button .info.toggle -text " config " -command toggleConfig -padx 1 -pady 1 -relief flat -bd 0 -bg #37BC7D -activebackground #F54927
  pack .info.toggle -side left
  pack .info.note -side left -fill x;# -padx 5
  pack .info

  # Create frame for input fields
  frame .config
  pack .config -side top -fill x -padx 4 -pady 4

  # Create labels and entry fields for A, B, C, and Format
  label .config.labelA -text "min"
  entry .config.entryA -textvariable min_val -width 10
  grid .config.labelA .config.entryA -sticky w -padx 5 -pady 2

  label .config.labelB -text "max"
  entry .config.entryB -textvariable max_val -width 10
  grid .config.labelB .config.entryB -sticky w -padx 5 -pady 2

  label .config.labelC -text "step"
  entry .config.entryC -textvariable step_val -width 10
  grid .config.labelC .config.entryC -sticky w -padx 5 -pady 2

  label .config.labelFormat -text "wire"
  entry .config.entryFormat -textvariable wire_string -width 20
  checkbutton .config.entryCheck -variable wire_check -text {}
  grid .config.labelFormat .config.entryFormat .config.entryCheck -sticky w -padx 5 -pady 2

  # Update button
  button .config.update -text " update " -command updateSlider -padx 1 -pady 1 -relief flat -bd 0 -bg orange -activebackground red
  grid .config.update -columnspan 3 -pady 2 -sticky w

  # Bind Enter key to update slider for each entry field
  bind .config.entryA <Return> updateSlider
  bind .config.entryB <Return> updateSlider
  bind .config.entryC <Return> updateSlider
  bind .config.entryFormat <Return> updateSlider

  frame .content
  frame .content.buttonGrid
  set voice -1

  for {set i 0} {$i < 32} {incr i} {
    button .content.buttonGrid.b$i -text " v$i " -padx 1 -pady 1 -font {Arial 10} -bd 0 \
      -command "toggleButton $i" -bg lightblue
    grid .content.buttonGrid.b$i -row [expr {$i / 16}] -column [expr {$i % 16}] \
      -sticky nsew
  }

  pack .content.buttonGrid -side left -side top -fill x -pady 1
  pack .content -padx 4 -pady 4

  # Create frame for slider
  frame .sliderFrame -bd 0 ;# -relief raised -bd 1
  pack .sliderFrame -side top -fill both -expand true -padx 4 -pady 1

  # Create the slider
  scale .slider -from $min_val -to $max_val -resolution $step_val \
    -orient horizontal -variable current_val -command {fire}
  pack .slider -in .sliderFrame -side top -fill x -pady 10
} else {
  daemonize
}

proc fire {value} {
    global current_val wire_string
    set tmp $wire_string
    if {$::voice >= 0} {
      set tmp "v$::voice $wire_string"
    } {
      set tmp $wire_string
    }
    global wire_check
    if {$wire_check == 0} {
      set fmt $tmp
    } {
      set fmt "\[$tmp\]"
    }
    set current_val $value
    set formattedOutput [format $fmt $value]
    wire $formattedOutput
}

# Procedure to update slider configuration
proc updateSlider {} {
    global min_val max_val step_val current_val
    
    # Validate inputs
    if {![string is double $min_val] || ![string is double $max_val] || ![string is double $step_val]} {
        tk_messageBox -type ok -icon error -title "Error" -message "Please enter valid numeric values"
        return
    }
    
    if {$step_val <= 0} {
        tk_messageBox -type ok -icon error -title "Error" -message "Step value must be greater than 0"
        return
    }
    
    if {$min_val >= $max_val} {
        tk_messageBox -type ok -icon error -title "Error" -message "Minimum value must be less than maximum value"
        return
    }
    
    # Temporarily remove the command to prevent fire from being called
    .slider configure -command {}
    
    # Update slider configuration
    .slider configure -from $min_val -to $max_val -resolution $step_val
    
    # Only adjust current value if it's outside the new range
    if {$current_val < $min_val || $current_val > $max_val} {
        set current_val $min_val
    }
    
    # Restore the command after updating
    .slider configure -command {fire}
}

proc main {min_val max_val step_val current_val wire_string wire_check window_title} {
# Create main window
}
